diff --git git/arch/arm/mach-omap2/board-overo.c git/arch/arm/mach-omap2/board-overo.c
index c3c1e94..be0e6cb 100644
--- git/arch/arm/mach-omap2/board-overo.c
+++ git/arch/arm/mach-omap2/board-overo.c
@@ -36,6 +36,8 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/partitions.h>
 #include <linux/mmc/host.h>
+#include <linux/pps-gpio.h>
+
 
 #include <asm/mach-types.h>
 #include <asm/mach/arch.h>
@@ -74,6 +76,18 @@
 #define OVERO_SMSC911X2_CS     4
 #define OVERO_SMSC911X2_GPIO   65
 
+
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * TI ADS7846 touch screen controller Section
+ *
+ * DB: Touch screen support is *DISABLED* in MOOS-AUV kernel configurations
+-----------------------------------------------------------------------------*/
 #if defined(CONFIG_TOUCHSCREEN_ADS7846) || \
 	defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
 
@@ -84,11 +98,13 @@ static struct omap2_mcspi_device_config ads7846_mcspi_config = {
 	.single_channel	= 1,	/* 0: slave, 1: master */
 };
 
+
 static int ads7846_get_pendown_state(void)
 {
 	return !gpio_get_value(OVERO_GPIO_PENDOWN);
 }
 
+
 static struct ads7846_platform_data ads7846_config = {
 	.x_max			= 0x0fff,
 	.y_max			= 0x0fff,
@@ -146,6 +162,16 @@ static void __init overo_ads7846_init(void)
 static inline void __init overo_ads7846_init(void) { return; }
 #endif
 
+
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * SMSC LAN91C111 Ethernet Controller
+-----------------------------------------------------------------------------*/
 #if defined(CONFIG_SMSC911X) || defined(CONFIG_SMSC911X_MODULE)
 
 #include <linux/smsc911x.h>
@@ -255,6 +281,15 @@ static inline void __init overo_init_smsc911x(void)
 static inline void __init overo_init_smsc911x(void) { return; }
 #endif
 
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * DVI/LCD Controller
+-----------------------------------------------------------------------------*/
 /* DSS */
 static int lcd_enabled;
 static int dvi_enabled;
@@ -264,6 +299,10 @@ static int dvi_enabled;
 
 static void __init overo_display_init(void)
 {
+    /* Export OVERO signal GPIO144_GPT9_PWM to userspace
+     *    Direction: OUTPUT (cannot be changed)
+     *    Initial State: 1
+     */
 	if ((gpio_request(OVERO_GPIO_LCD_EN, "OVERO_GPIO_LCD_EN") == 0) &&
 	    (gpio_direction_output(OVERO_GPIO_LCD_EN, 1) == 0))
 		gpio_export(OVERO_GPIO_LCD_EN, 0);
@@ -271,6 +310,10 @@ static void __init overo_display_init(void)
 		printk(KERN_ERR "could not obtain gpio for "
 					"OVERO_GPIO_LCD_EN\n");
 
+    /* Export OVERO signal GPIO145_GPT10_PWM to userspace
+     *    Direction: OUTPUT (cannot be changed)
+     *    Initial State: 1
+     */
 	if ((gpio_request(OVERO_GPIO_LCD_BL, "OVERO_GPIO_LCD_BL") == 0) &&
 	    (gpio_direction_output(OVERO_GPIO_LCD_BL, 1) == 0))
 		gpio_export(OVERO_GPIO_LCD_BL, 0);
@@ -378,6 +421,18 @@ static struct omap_dss_board_info overo_dss_data = {
 	.default_device	= &overo_dvi_device,
 };
 
+
+
+
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * ???
+-----------------------------------------------------------------------------*/
 static struct regulator_consumer_supply overo_vdda_dac_supply =
 	REGULATOR_SUPPLY("vdda_dac", "omapdss_venc");
 
@@ -386,6 +441,14 @@ static struct regulator_consumer_supply overo_vdds_dsi_supply[] = {
 	REGULATOR_SUPPLY("vdds_dsi", "omapdss_dsi1"),
 };
 
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO NAND FLASH interface
+-----------------------------------------------------------------------------*/
 static struct mtd_partition overo_nand_partitions[] = {
 	{
 		.name           = "xloader",
@@ -454,6 +517,13 @@ static void __init overo_flash_init(void)
 	}
 }
 
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO MMC interface
+-----------------------------------------------------------------------------*/
 static struct omap2_hsmmc_info mmc[] = {
 	{
 		.mmc		= 1,
@@ -476,24 +546,49 @@ static struct regulator_consumer_supply overo_vmmc1_supply = {
 	.supply			= "vmmc",
 };
 
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO GPIO for platform LED's
+-----------------------------------------------------------------------------*/
 #if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
 #include <linux/leds.h>
 
 static struct gpio_led gpio_leds[] = {
-	{
-		.name			= "overo:red:gpio21",
+	{   /* [0] Heartbeat LED (LED1) on carrier board */
+		.name			= "auv:blu:led1",
 		.default_trigger	= "heartbeat",
 		.gpio			= 21,
 		.active_low		= true,
 	},
-	{
-		.name			= "overo:blue:gpio22",
+	{   /* [1] Green status LED (LED5) on carrier board driven by GPIO67 */
+		.name			= "auv:grn:led5",
 		.default_trigger	= "none",
-		.gpio			= 22,
+		.gpio			= 67,
 		.active_low		= true,
 	},
-	{
-		.name			= "overo:blue:COM",
+	{   /* [2] Green status LED (LED6) on carrier board driven by GPIO68 */
+		.name			= "auv:grn:led6",
+		.default_trigger	= "none",
+		.gpio			= 68,
+		.active_low		= true,
+	},
+	{   /* [3] Green status LED (LED7) on carrier board driven by GPIO90 */
+		.name			= "auv:grn:led7",
+		.default_trigger	= "none",
+		.gpio			= 90,
+		.active_low		= true,
+	},
+	{   /* [4] Red status LED (LED8) on carrier board driven by GPIO93 */
+		.name			= "auv:red:led8",
+		.default_trigger	= "none",
+		.gpio			= 93,
+		.active_low		= true,
+	},
+	{   /* [5] Blue (WiFi) LED on the OVERO COM itself */
+		.name			= "overo:blu:COM",
 		.default_trigger	= "mmc0",
 		.gpio			= -EINVAL,	/* gets replaced */
 		.active_low		= true,
@@ -522,47 +617,57 @@ static void __init overo_init_led(void)
 static inline void __init overo_init_led(void) { return; }
 #endif
 
-#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
-#include <linux/input.h>
-#include <linux/gpio_keys.h>
 
-static struct gpio_keys_button gpio_buttons[] = {
-	{
-		.code			= BTN_0,
-		.gpio			= 23,
-		.desc			= "button0",
-		.wakeup			= 1,
-	},
-	{
-		.code			= BTN_1,
-		.gpio			= 14,
-		.desc			= "button1",
-		.wakeup			= 1,
-	},
-};
 
-static struct gpio_keys_platform_data gpio_keys_pdata = {
-	.buttons	= gpio_buttons,
-	.nbuttons	= ARRAY_SIZE(gpio_buttons),
-};
 
-static struct platform_device gpio_keys_device = {
-	.name	= "gpio-keys",
-	.id	= -1,
-	.dev	= {
-		.platform_data	= &gpio_keys_pdata,
-	},
-};
 
-static void __init overo_init_keys(void)
+
+
+/*-----------------------------------------------------------------------------
+ * Export GPIO pins to user space
+-----------------------------------------------------------------------------*/
+#define OVERO_GPIO_GPS_ENABLE       87
+#define OVERO_GPIO_SLEEP_PSOC_RESET 66
+static void __init overo_export_userspace_gpio(void)
 {
-	platform_device_register(&gpio_keys_device);
+
+    /* Export GPS serial data input enable pin
+     *    Direction: OUTPUT (cannot be changed)
+     *    Initial State: 0
+     */
+	if ( (gpio_request(OVERO_GPIO_GPS_ENABLE, "OVERO_GPIO_GPS_ENABLE") == 0) &&
+	     (gpio_direction_output(OVERO_GPIO_GPS_ENABLE, 0) == 0) ) 
+    {
+		gpio_export(OVERO_GPIO_GPS_ENABLE, 0);
+    }
+	else
+    {
+		printk(KERN_ERR "Failed to export OVERO_GPIO_GPS_ENABLE!\n");
+    }
+
+
+    /* Export GPIO66 ("SLEEP" pin on FSD board; PSOC_RESET on BSD board)
+     *    Direction: OUTPUT (can be changed)
+     *    Initial State: 0
+     */
+	if ( (gpio_request(OVERO_GPIO_SLEEP_PSOC_RESET, 
+                       "OVERO_GPIO_SLEEP_PSOC_RESET") == 0) &&
+	     (gpio_direction_output(OVERO_GPIO_SLEEP_PSOC_RESET, 1) == 0) ) 
+    {
+		gpio_export(OVERO_GPIO_SLEEP_PSOC_RESET, 0);
+    }
+	else
+    {
+		printk(KERN_ERR "Failed to export OVERO_GPIO_SLEEP_PSOC_RESET!\n");
+    }
+    
 }
 
-#else
-static inline void __init overo_init_keys(void) { return; }
-#endif
 
+
+/*-----------------------------------------------------------------------------
+ * TWL4030 (TPS65950) voltage control (???)
+-----------------------------------------------------------------------------*/
 static int overo_twl_gpio_setup(struct device *dev,
 		unsigned gpio, unsigned ngpio)
 {
@@ -572,7 +677,7 @@ static int overo_twl_gpio_setup(struct device *dev,
 
 #if defined(CONFIG_LEDS_GPIO) || defined(CONFIG_LEDS_GPIO_MODULE)
 	/* TWL4030_GPIO_MAX + 1 == ledB, PMU_STAT (out, active low LED) */
-	gpio_leds[2].gpio = gpio + TWL4030_GPIO_MAX + 1;
+	gpio_leds[5].gpio = gpio + TWL4030_GPIO_MAX + 1;
 #endif
 
 	return 0;
@@ -604,6 +709,13 @@ static struct regulator_init_data overo_vmmc1 = {
 	.consumer_supplies	= &overo_vmmc1_supply,
 };
 
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * TWL4030 (TPS65950) video and audio I/O
+-----------------------------------------------------------------------------*/
 /* VDAC for DSS driving S-Video (8 mA unloaded, max 65 mA) */
 static struct regulator_init_data overo_vdac = {
 	.constraints = {
@@ -633,6 +745,7 @@ static struct regulator_init_data overo_vpll2 = {
 	.consumer_supplies	= overo_vdds_dsi_supply,
 };
 
+
 static struct twl4030_codec_audio_data overo_audio_data;
 
 static struct twl4030_codec_data overo_codec_data = {
@@ -644,6 +757,7 @@ static struct twl4030_madc_platform_data overo_madc_data = {
 	.irq_line	= 1,
 };
 
+/* TWL4030 (TPS65950) device data */
 static struct twl4030_platform_data overo_twldata = {
 	.irq_base	= TWL4030_IRQ_BASE,
 	.irq_end	= TWL4030_IRQ_END,
@@ -656,6 +770,16 @@ static struct twl4030_platform_data overo_twldata = {
 	.vpll2		= &overo_vpll2,
 };
 
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO I2C
+-----------------------------------------------------------------------------*/
+
+/* I2C device descriptor for the TWL4030 (TPS65950) */
 static struct i2c_board_info __initdata overo_i2c_boardinfo[] = {
 	{
 		I2C_BOARD_INFO("tps65950", 0x48),
@@ -665,6 +789,7 @@ static struct i2c_board_info __initdata overo_i2c_boardinfo[] = {
 	},
 };
 
+/* Registers an I2C bus for the OVERO */
 static int __init overo_i2c_init(void)
 {
 	omap_register_i2c_bus(1, 2600, overo_i2c_boardinfo,
@@ -674,6 +799,14 @@ static int __init overo_i2c_init(void)
 	return 0;
 }
 
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO SPI
+-----------------------------------------------------------------------------*/
 static struct spi_board_info overo_spi_board_info[] __initdata = {
 #if defined(CONFIG_TOUCHSCREEN_ADS7846) || \
 	defined(CONFIG_TOUCHSCREEN_ADS7846_MODULE)
@@ -695,6 +828,8 @@ static struct spi_board_info overo_spi_board_info[] __initdata = {
 		.mode			= SPI_MODE_0,
 	},
 #endif
+
+
 #if defined(CONFIG_PANEL_LGPHILIPS_LB035Q02) || \
 	defined(CONFIG_PANEL_LGPHILIPS_LB035Q02_MODULE)
 	{
@@ -730,6 +865,15 @@ static void __init overo_init_early(void)
 				  mt46h32m32lf6_sdrc_params);
 }
 
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO USB HOST port configuration
+-----------------------------------------------------------------------------*/
 static const struct usbhs_omap_board_data usbhs_bdata __initconst = {
 	.port_mode[0] = OMAP_USBHS_PORT_MODE_UNUSED,
 	.port_mode[1] = OMAP_EHCI_PORT_MODE_PHY,
@@ -740,24 +884,38 @@ static const struct usbhs_omap_board_data usbhs_bdata __initconst = {
 	.reset_gpio_port[2]  = -EINVAL
 };
 
+
+
+/*-----------------------------------------------------------------------------
+ * OMAP pin mux settings to be applied when kernel starts
+-----------------------------------------------------------------------------*/
 #ifdef CONFIG_OMAP_MUX
 static struct omap_board_mux board_mux[] __initdata = {
 	{ .reg_offset = OMAP_MUX_TERMINATOR },
 };
 #endif
 
+
+
+/*-----------------------------------------------------------------------------
+ * USB OTG port configuration
+-----------------------------------------------------------------------------*/
 static struct omap_musb_board_data musb_board_data = {
 	.interface_type		= MUSB_INTERFACE_ULPI,
-#if defined(CONFIG_USB_MUSB_OTG)
-	.mode			= MUSB_OTG,
-#elif defined(CONFIG_USB_GADGET_MUSB_HDRC)
-	.mode			= MUSB_PERIPHERAL,
-#else
-	.mode			= MUSB_HOST,
-#endif
-	.power			= 100,
+	.mode			= MUSB_HOST,    /* port mode (OTG, periph, host) */
+	.power			= 100,          /* max current (mA) port can supply */
 };
 
+
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO CPU operating mode and DSP (if detected)
+-----------------------------------------------------------------------------*/
 static void __init overo_opp_init(void)
 {
 	int r = 0;
@@ -807,26 +965,95 @@ static void __init overo_opp_init(void)
 	return;
 }
 
+
+
+
+/*-----------------------------------------------------------------------------
+ * DB: Set up PPS input from a GPIO pin
+-----------------------------------------------------------------------------*/
+#define GPS_PPS_PIN     145
+
+static struct pps_gpio_platform_data pps_gpio_pdata  = {
+	.assert_falling_edge = false,   /* Treat falling edge as PPS event */
+	.capture_clear = false,         /* Capture falling edges (?) */
+	.gpio_pin = GPS_PPS_PIN,        /* GPIO pin number */
+	.gpio_label = "PPS",        /* GPIO device name */
+};
+
+static struct platform_device pps_gpio_pdevice = {
+	.name	= "pps-gpio",
+	.id	= GPS_PPS_PIN,
+	.dev	= {
+		.platform_data	= &pps_gpio_pdata,
+	},
+};
+
+static void __init overo_init_pps_gpio(void)
+{
+	if ( platform_device_register(&pps_gpio_pdevice) != 0 ) {
+        printk(KERN_WARNING "Failed to register PPS GPIO device!\n");
+    }
+}
+
+
+
+
+
+
+
+/*-----------------------------------------------------------------------------
+ * OVERO board initialization
+-----------------------------------------------------------------------------*/
 static void __init overo_init(void)
 {
+    /* Apply any pinmux settings defined above in board_mux */
 	omap3_mux_init(board_mux, OMAP_PACKAGE_CBB);
+
+    /* Register OVERO I2C bus and TPS65950 I2C device */
 	overo_i2c_init();
-	omap_display_init(&overo_dss_data);
+
+    /* DB: MOOS-AUV PCB's do not have any video facilities! */
+	/*omap_display_init(&overo_dss_data);*/
+
+    /* Initialize OMAP serial ports (/dev/ttyO0, /dev/ttyO1, /dev/ttyO2) */
 	omap_serial_init();
+
+    /* Register OVERO NAND FLASH */
 	overo_flash_init();
+
+    /* Configure OVERO USB OTG port mode and current */
 	usb_musb_init(&musb_board_data);
+
+    /* Configure OVERO USB host port */
 	usbhs_init(&usbhs_bdata);
-	overo_spi_init();
+
+    /* Initialize OVERO SPI bus 
+     * DB: MOOS-AUV PCB's do not expose any SPI I/O */
+	/*overo_spi_init();*/
+
+    /* Initialize SMSC Ethernet controller */
 	overo_init_smsc911x();
-	overo_display_init();
+
+    /* DB: MOOS-AUV PCB's do not have any display facilities! */
+    /*overo_display_init();*/
+
+    /* Register OVERO and heartbeat LED's */
 	overo_init_led();
-	overo_init_keys();
+
+    /* Export GPIO pins to userspace */
+	overo_export_userspace_gpio();
+
+    /* Init OMAP operating point and DSP */
 	overo_opp_init();
 
+    /* Initialize GPS PPS input device using GPIO pin */
+    overo_init_pps_gpio();
+
 	/* Ensure SDRC pins are mux'd for self-refresh */
 	omap_mux_init_signal("sdrc_cke0", OMAP_PIN_OUTPUT);
 	omap_mux_init_signal("sdrc_cke1", OMAP_PIN_OUTPUT);
 
+    /* Initialize remaining OVERO GPIO */
 	if ((gpio_request(OVERO_GPIO_W2W_NRESET,
 			  "OVERO_GPIO_W2W_NRESET") == 0) &&
 	    (gpio_direction_output(OVERO_GPIO_W2W_NRESET, 1) == 0)) {
